// Enhanced material system for Sprout Engine
// Provides PBR material editing and management capabilities with visual node editor

use bevy::prelude::*;
use bevy_egui::{egui, EguiContexts};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct SproutMaterial {
    pub name: String,
    pub albedo_color: [f32; 4],
    pub metallic: f32,
    pub roughness: f32,
    pub emission: [f32; 3],
    pub emission_strength: f32,
    pub normal_strength: f32,
    pub albedo_texture: Option<String>,
    pub normal_texture: Option<String>,
    pub metallic_roughness_texture: Option<String>,
    pub emission_texture: Option<String>,
    pub occlusion_texture: Option<String>,
    pub material_graph: MaterialGraph,  // Visual node graph for the material
}

// Node-based material system structures
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum MaterialNodeType {
    // Input nodes
    TextureSample,
    ColorConstant,
    ScalarConstant,
    Vector3Constant,
    
    // Math nodes
    Multiply,
    Add,
    Subtract,
    Lerp,
    
    // Output node (there's always one)
    MaterialOutput,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct MaterialNode {
    pub id: u32,
    pub node_type: MaterialNodeType,
    pub position: [f32; 2],
    pub inputs: HashMap<String, MaterialValue>,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum MaterialValue {
    Color([f32; 4]),
    Scalar(f32),
    Vector3([f32; 3]),
    Texture(String),
    Connection { node_id: u32, output_name: String },
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct MaterialConnection {
    pub from_node: u32,
    pub from_output: String,
    pub to_node: u32,
    pub to_input: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct MaterialGraph {
    pub nodes: Vec<MaterialNode>,
    pub connections: Vec<MaterialConnection>,
    pub next_node_id: u32,
}

impl Default for MaterialGraph {
    fn default() -> Self {
        let mut graph = Self {
            nodes: Vec::new(),
            connections: Vec::new(),
            next_node_id: 2,
        };
        
        // Always start with a Material Output node
        graph.nodes.push(MaterialNode {
            id: 1,
            node_type: MaterialNodeType::MaterialOutput,
            position: [400.0, 200.0],
            inputs: HashMap::from([
                ("Base Color".to_string(), MaterialValue::Color([0.8, 0.8, 0.8, 1.0])),
                ("Metallic".to_string(), MaterialValue::Scalar(0.0)),
                ("Roughness".to_string(), MaterialValue::Scalar(0.5)),
                ("Emission".to_string(), MaterialValue::Color([0.0, 0.0, 0.0, 1.0])),
            ]),
            name: "Material Output".to_string(),
        });
        
        graph
    }
}

impl Default for SproutMaterial {
    fn default() -> Self {
        Self {
            name: "New Material".to_string(),
            albedo_color: [0.8, 0.8, 0.8, 1.0],
            metallic: 0.0,
            roughness: 0.5,
            emission: [0.0, 0.0, 0.0],
            emission_strength: 1.0,
            normal_strength: 1.0,
            albedo_texture: None,
            normal_texture: None,
            metallic_roughness_texture: None,
            emission_texture: None,
            occlusion_texture: None,
            material_graph: MaterialGraph::default(),
        }
    }
}

#[derive(Resource, Serialize, Deserialize)]
pub struct MaterialLibrary {
    pub materials: HashMap<String, SproutMaterial>,
    pub selected_material: Option<String>,
}

#[derive(Resource)]
pub struct MaterialEditorState {
    pub show_node_editor: bool,
    pub selected_node: Option<u32>,
    pub dragging_node: Option<u32>,
    pub drag_offset: [f32; 2],
    pub creating_connection: Option<(u32, String)>, // (from_node_id, output_name)
}

impl Default for MaterialEditorState {
    fn default() -> Self {
        Self {
            show_node_editor: false,
            selected_node: None,
            dragging_node: None,
            drag_offset: [0.0, 0.0],
            creating_connection: None,
        }
    }
}

impl Default for MaterialLibrary {
    fn default() -> Self {
        let mut materials = HashMap::new();

        // Add some default materials
        materials.insert("Default".to_string(), SproutMaterial {
            name: "Default".to_string(),
            ..Default::default()
        });

        materials.insert("Metal".to_string(), SproutMaterial {
            name: "Metal".to_string(),
            albedo_color: [0.7, 0.7, 0.7, 1.0],
            metallic: 1.0,
            roughness: 0.2,
            ..Default::default()
        });

        materials.insert("Plastic".to_string(), SproutMaterial {
            name: "Plastic".to_string(),
            albedo_color: [0.1, 0.5, 0.9, 1.0],
            metallic: 0.0,
            roughness: 0.8,
            ..Default::default()
        });

        Self {
            materials,
            selected_material: Some("Default".to_string()),
        }
    }
}

pub fn material_editor_ui(
    mut contexts: EguiContexts,
    mut material_library: ResMut<MaterialLibrary>,
    mut editor_state: ResMut<MaterialEditorState>,
    asset_server: Res<AssetServer>,
    mut bevy_materials: ResMut<Assets<StandardMaterial>>,
) {
    // Material Browser Window
    egui::Window::new("Material Browser")
        .default_open(true)
        .resizable(true)
        .default_size([300.0, 400.0])
        .show(contexts.ctx_mut(), |ui| {

        ui.horizontal(|ui| {
            ui.label("Material:");

            egui::ComboBox::from_label("")
                .selected_text(material_library.selected_material.as_ref().unwrap_or(&"None".to_string()))
                .show_ui(ui, |ui| {
                    let material_names: Vec<String> = material_library.materials.keys().cloned().collect();
                    for material_name in material_names {
                        ui.selectable_value(&mut material_library.selected_material, Some(material_name.clone()), material_name);
                    }
                });

            if ui.button("New").clicked() {
                let new_name = format!("Material_{}", material_library.materials.len());
                material_library.materials.insert(new_name.clone(), SproutMaterial {
                    name: new_name.clone(),
                    ..Default::default()
                });
                material_library.selected_material = Some(new_name);
            }

            if ui.button("Delete").clicked() {
                if let Some(selected) = material_library.selected_material.clone() {
                    if selected != "Default" { // Don't delete the default material
                        material_library.materials.remove(&selected);
                        material_library.selected_material = Some("Default".to_string());
                    }
                }
            }
        });

        ui.separator();

        // Node Editor Button
        if ui.button("Open Node Editor").clicked() {
            editor_state.show_node_editor = true;
        }

        ui.separator();

        // Material Properties (read-only, computed from graph)
        if let Some(selected_name) = &material_library.selected_material.clone() {
            if let Some(material) = material_library.materials.get(selected_name) {
                ui.label("Material Properties (computed from graph):");
                
                ui.horizontal(|ui| {
                    ui.label("Base Color:");
                    let color = material.albedo_color;
                    ui.colored_label(
                        egui::Color32::from_rgba_premultiplied(
                            (color[0] * 255.0) as u8,
                            (color[1] * 255.0) as u8,
                            (color[2] * 255.0) as u8,
                            255,
                        ),
                        "█████"
                    );
                });
                
                ui.label(format!("Metallic: {:.2}", material.metallic));
                ui.label(format!("Roughness: {:.2}", material.roughness));
                ui.label(format!("Nodes in graph: {}", material.material_graph.nodes.len()));
            }
        }
    });

    // Visual Node Editor Window
    if editor_state.show_node_editor {
        material_node_editor_ui(contexts.ctx_mut(), &mut material_library, &mut editor_state);
    }
}

pub fn material_node_editor_ui(
    ctx: &mut egui::Context,
    material_library: &mut MaterialLibrary,
    editor_state: &mut MaterialEditorState,
) {
    egui::Window::new("Material Node Editor")
        .default_open(true)
        .resizable(true)
        .default_size([800.0, 600.0])
        .show(ctx, |ui| {
            
            if ui.button("Close Node Editor").clicked() {
                editor_state.show_node_editor = false;
                return;
            }

            if let Some(selected_name) = &material_library.selected_material.clone() {
                if let Some(material) = material_library.materials.get_mut(selected_name) {
                    
                    ui.separator();
                    
                    // Add Node buttons
                    ui.horizontal(|ui| {
                        ui.label("Add Node:");
                        
                        if ui.button("Color Constant").clicked() {
                            add_node(&mut material.material_graph, MaterialNodeType::ColorConstant, "Color");
                        }
                        
                        if ui.button("Scalar Constant").clicked() {
                            add_node(&mut material.material_graph, MaterialNodeType::ScalarConstant, "Scalar");
                        }
                        
                        if ui.button("Texture Sample").clicked() {
                            add_node(&mut material.material_graph, MaterialNodeType::TextureSample, "Texture");
                        }
                        
                        if ui.button("Multiply").clicked() {
                            add_node(&mut material.material_graph, MaterialNodeType::Multiply, "Multiply");
                        }
                        
                        if ui.button("Add").clicked() {
                            add_node(&mut material.material_graph, MaterialNodeType::Add, "Add");
                        }
                    });
                    
                    ui.separator();
                    
                    // Node canvas
                    let response = ui.allocate_response(
                        egui::vec2(ui.available_width(), 400.0),
                        egui::Sense::click_and_drag()
                    );
                    
                    let painter = ui.painter_at(response.rect);
                    
                    // Draw background grid
                    draw_grid(&painter, response.rect);
                    
                    // Draw connections first (so they appear behind nodes)
                    for connection in &material.material_graph.connections {
                        draw_connection(&painter, &material.material_graph, connection, response.rect);
                    }
                    
                    // Draw nodes
                    for node in &mut material.material_graph.nodes {
                        draw_node(
                            &painter, 
                            ui, 
                            node, 
                            response.rect, 
                            editor_state,
                            &response
                        );
                    }
                    
                    // Handle node interactions
                    handle_node_interactions(
                        &mut material.material_graph,
                        editor_state,
                        &response,
                        ctx
                    );
                    
                    // Compile material from graph
                    compile_material_from_graph(material);
                }
            }
        });
}
                ui.heading("Properties");

                ui.horizontal(|ui| {
                    ui.label("Name:");
                    ui.text_edit_singleline(&mut material.name);
                });

                ui.separator();

                // Albedo color
                ui.horizontal(|ui| {
                    ui.label("Albedo:");
                    ui.color_edit_button_rgba_unmultiplied(&mut material.albedo_color);
                });

                // Metallic
                ui.horizontal(|ui| {
                    ui.label("Metallic:");
                    ui.add(egui::Slider::new(&mut material.metallic, 0.0..=1.0));
                });

                // Roughness
                ui.horizontal(|ui| {
                    ui.label("Roughness:");
                    ui.add(egui::Slider::new(&mut material.roughness, 0.0..=1.0));
                });

                ui.separator();

                // Emission
                ui.horizontal(|ui| {
                    ui.label("Emission:");
                    ui.color_edit_button_rgb(&mut material.emission);
                });

                ui.horizontal(|ui| {
                    ui.label("Emission Strength:");
                    ui.add(egui::Slider::new(&mut material.emission_strength, 0.0..=10.0));
                });

                ui.separator();

                // Normal strength
                ui.horizontal(|ui| {
                    ui.label("Normal Strength:");
                    ui.add(egui::Slider::new(&mut material.normal_strength, 0.0..=2.0));
                });

                ui.separator();
                ui.heading("Textures");

                // Texture slots
                texture_slot_ui(ui, "Albedo", &mut material.albedo_texture);
                texture_slot_ui(ui, "Normal", &mut material.normal_texture);
                texture_slot_ui(ui, "Metallic/Roughness", &mut material.metallic_roughness_texture);
                texture_slot_ui(ui, "Emission", &mut material.emission_texture);
                texture_slot_ui(ui, "Occlusion", &mut material.occlusion_texture);

                ui.separator();

                if ui.button("Apply to Selected Objects").clicked() {
                    // This would apply the material to selected objects
                    // For now, we'll just create a Bevy StandardMaterial
                    let bevy_material = create_bevy_material(material, &asset_server);
                    bevy_materials.add(bevy_material);
                }
            }
        }
    });
}

fn texture_slot_ui(ui: &mut egui::Ui, label: &str, texture_path: &mut Option<String>) {
    ui.horizontal(|ui| {
        ui.label(label);

        let display_text = texture_path.as_ref()
            .map(|path| path.split('/').last().unwrap_or(path))
            .unwrap_or("None");

        ui.text_edit_singleline(&mut display_text.to_string());

        if ui.button("Browse").clicked() {
            // In a real implementation, this would open a file dialog
            // For now, we'll use a placeholder
            *texture_path = Some("assets/textures/placeholder.png".to_string());
        }

        if ui.button("Clear").clicked() {
            *texture_path = None;
        }
    });
}

fn create_bevy_material(sprout_material: &SproutMaterial, asset_server: &AssetServer) -> StandardMaterial {
    let mut material = StandardMaterial {
        base_color: Color::rgba(
            sprout_material.albedo_color[0],
            sprout_material.albedo_color[1],
            sprout_material.albedo_color[2],
            sprout_material.albedo_color[3],
        ),
        metallic: sprout_material.metallic,
        perceptual_roughness: sprout_material.roughness,
        emissive: Color::rgb(
            sprout_material.emission[0] * sprout_material.emission_strength,
            sprout_material.emission[1] * sprout_material.emission_strength,
            sprout_material.emission[2] * sprout_material.emission_strength,
        ),
        ..default()
    };

    // Load textures if specified
    if let Some(albedo_path) = &sprout_material.albedo_texture {
        material.base_color_texture = Some(asset_server.load(albedo_path));
    }

    if let Some(normal_path) = &sprout_material.normal_texture {
        material.normal_map_texture = Some(asset_server.load(normal_path));
    }

    if let Some(metallic_roughness_path) = &sprout_material.metallic_roughness_texture {
        material.metallic_roughness_texture = Some(asset_server.load(metallic_roughness_path));
    }

    if let Some(emission_path) = &sprout_material.emission_texture {
        material.emissive_texture = Some(asset_server.load(emission_path));
    }

    if let Some(occlusion_path) = &sprout_material.occlusion_texture {
        material.occlusion_texture = Some(asset_server.load(occlusion_path));
    }

    material
}

pub fn save_material_library(material_library: &MaterialLibrary, path: &str) -> Result<(), Box<dyn std::error::Error>> {
    let json = serde_json::to_string_pretty(material_library)?;
    std::fs::write(path, json)?;
    Ok(())
}

pub fn load_material_library(path: &str) -> Result<MaterialLibrary, Box<dyn std::error::Error>> {
    let json = std::fs::read_to_string(path)?;
    let library = serde_json::from_str(&json)?;
    Ok(library)
}

// Helper functions for the node editor

fn add_node(graph: &mut MaterialGraph, node_type: MaterialNodeType, name: &str) {
    let node = MaterialNode {
        id: graph.next_node_id,
        node_type: node_type.clone(),
        position: [100.0, 100.0],
        inputs: get_default_inputs_for_node_type(&node_type),
        name: format!("{} {}", name, graph.next_node_id),
    };
    
    graph.nodes.push(node);
    graph.next_node_id += 1;
}

fn get_default_inputs_for_node_type(node_type: &MaterialNodeType) -> HashMap<String, MaterialValue> {
    match node_type {
        MaterialNodeType::ColorConstant => {
            HashMap::from([
                ("Color".to_string(), MaterialValue::Color([1.0, 1.0, 1.0, 1.0])),
            ])
        },
        MaterialNodeType::ScalarConstant => {
            HashMap::from([
                ("Value".to_string(), MaterialValue::Scalar(1.0)),
            ])
        },
        MaterialNodeType::Vector3Constant => {
            HashMap::from([
                ("Vector".to_string(), MaterialValue::Vector3([1.0, 1.0, 1.0])),
            ])
        },
        MaterialNodeType::TextureSample => {
            HashMap::from([
                ("Texture".to_string(), MaterialValue::Texture("".to_string())),
                ("UV".to_string(), MaterialValue::Vector3([0.0, 0.0, 0.0])),
            ])
        },
        MaterialNodeType::Multiply => {
            HashMap::from([
                ("A".to_string(), MaterialValue::Scalar(1.0)),
                ("B".to_string(), MaterialValue::Scalar(1.0)),
            ])
        },
        MaterialNodeType::Add => {
            HashMap::from([
                ("A".to_string(), MaterialValue::Scalar(0.0)),
                ("B".to_string(), MaterialValue::Scalar(0.0)),
            ])
        },
        MaterialNodeType::Subtract => {
            HashMap::from([
                ("A".to_string(), MaterialValue::Scalar(1.0)),
                ("B".to_string(), MaterialValue::Scalar(0.0)),
            ])
        },
        MaterialNodeType::Lerp => {
            HashMap::from([
                ("A".to_string(), MaterialValue::Color([0.0, 0.0, 0.0, 1.0])),
                ("B".to_string(), MaterialValue::Color([1.0, 1.0, 1.0, 1.0])),
                ("Alpha".to_string(), MaterialValue::Scalar(0.5)),
            ])
        },
        MaterialNodeType::MaterialOutput => {
            HashMap::from([
                ("Base Color".to_string(), MaterialValue::Color([0.8, 0.8, 0.8, 1.0])),
                ("Metallic".to_string(), MaterialValue::Scalar(0.0)),
                ("Roughness".to_string(), MaterialValue::Scalar(0.5)),
                ("Emission".to_string(), MaterialValue::Color([0.0, 0.0, 0.0, 1.0])),
            ])
        },
    }
}

fn draw_grid(painter: &egui::Painter, rect: egui::Rect) {
    let grid_size = 20.0;
    let color = egui::Color32::from_rgba_premultiplied(50, 50, 50, 255);
    
    // Vertical lines
    let mut x = rect.left();
    while x < rect.right() {
        painter.line_segment(
            [egui::pos2(x, rect.top()), egui::pos2(x, rect.bottom())],
            egui::Stroke::new(0.5, color),
        );
        x += grid_size;
    }
    
    // Horizontal lines
    let mut y = rect.top();
    while y < rect.bottom() {
        painter.line_segment(
            [egui::pos2(rect.left(), y), egui::pos2(rect.right(), y)],
            egui::Stroke::new(0.5, color),
        );
        y += grid_size;
    }
}

fn draw_connection(
    painter: &egui::Painter,
    graph: &MaterialGraph,
    connection: &MaterialConnection,
    canvas_rect: egui::Rect,
) {
    if let (Some(from_node), Some(to_node)) = (
        graph.nodes.iter().find(|n| n.id == connection.from_node),
        graph.nodes.iter().find(|n| n.id == connection.to_node),
    ) {
        let from_pos = egui::pos2(
            canvas_rect.left() + from_node.position[0] + 120.0, // Right side of output node
            canvas_rect.top() + from_node.position[1] + 20.0,
        );
        let to_pos = egui::pos2(
            canvas_rect.left() + to_node.position[0], // Left side of input node
            canvas_rect.top() + to_node.position[1] + 20.0,
        );
        
        // Draw bezier curve
        let control_offset = (to_pos.x - from_pos.x).abs() * 0.5;
        let control1 = egui::pos2(from_pos.x + control_offset, from_pos.y);
        let control2 = egui::pos2(to_pos.x - control_offset, to_pos.y);
        
        draw_bezier_curve(painter, from_pos, control1, control2, to_pos);
    }
}

fn draw_bezier_curve(
    painter: &egui::Painter,
    start: egui::Pos2,
    control1: egui::Pos2,
    control2: egui::Pos2,
    end: egui::Pos2,
) {
    let segments = 20;
    let color = egui::Color32::from_rgb(255, 255, 100);
    
    let mut points = Vec::new();
    for i in 0..=segments {
        let t = i as f32 / segments as f32;
        let point = bezier_point(start, control1, control2, end, t);
        points.push(point);
    }
    
    for i in 0..points.len() - 1 {
        painter.line_segment(
            [points[i], points[i + 1]],
            egui::Stroke::new(2.0, color),
        );
    }
}

fn bezier_point(
    p0: egui::Pos2,
    p1: egui::Pos2,
    p2: egui::Pos2,
    p3: egui::Pos2,
    t: f32,
) -> egui::Pos2 {
    let t2 = t * t;
    let t3 = t2 * t;
    let mt = 1.0 - t;
    let mt2 = mt * mt;
    let mt3 = mt2 * mt;
    
    egui::pos2(
        mt3 * p0.x + 3.0 * mt2 * t * p1.x + 3.0 * mt * t2 * p2.x + t3 * p3.x,
        mt3 * p0.y + 3.0 * mt2 * t * p1.y + 3.0 * mt * t2 * p2.y + t3 * p3.y,
    )
}

fn draw_node(
    painter: &egui::Painter,
    ui: &mut egui::Ui,
    node: &mut MaterialNode,
    canvas_rect: egui::Rect,
    editor_state: &mut MaterialEditorState,
    response: &egui::Response,
) {
    let node_pos = egui::pos2(
        canvas_rect.left() + node.position[0],
        canvas_rect.top() + node.position[1],
    );
    
    let node_size = egui::vec2(120.0, 80.0);
    let node_rect = egui::Rect::from_min_size(node_pos, node_size);
    
    // Node background
    let node_color = match node.node_type {
        MaterialNodeType::MaterialOutput => egui::Color32::from_rgb(100, 200, 100),
        MaterialNodeType::ColorConstant => egui::Color32::from_rgb(200, 100, 100),
        MaterialNodeType::ScalarConstant => egui::Color32::from_rgb(100, 100, 200),
        MaterialNodeType::TextureSample => egui::Color32::from_rgb(200, 150, 100),
        _ => egui::Color32::from_rgb(150, 150, 150),
    };
    
    painter.rect_filled(node_rect, egui::Rounding::same(5.0), node_color);
    painter.rect_stroke(node_rect, egui::Rounding::same(5.0), egui::Stroke::new(1.0, egui::Color32::WHITE));
    
    // Node title
    painter.text(
        egui::pos2(node_pos.x + 5.0, node_pos.y + 5.0),
        egui::Align2::LEFT_TOP,
        &node.name,
        egui::FontId::default(),
        egui::Color32::WHITE,
    );
    
    // Input/Output connectors would go here in a full implementation
    // For now, just show the node structure
}

fn handle_node_interactions(
    graph: &mut MaterialGraph,
    editor_state: &mut MaterialEditorState,
    response: &egui::Response,
    ctx: &mut egui::Context,
) {
    // Handle node dragging, selection, connection creation, etc.
    // This is a simplified version - a full implementation would be more complex
    
    if response.clicked() {
        // Handle node selection
    }
    
    if response.dragged() {
        // Handle node dragging
    }
}

fn compile_material_from_graph(material: &mut SproutMaterial) {
    // Find the Material Output node
    if let Some(output_node) = material.material_graph.nodes.iter()
        .find(|n| n.node_type == MaterialNodeType::MaterialOutput) {
        
        // Extract values from the output node
        if let Some(base_color) = output_node.inputs.get("Base Color") {
            if let MaterialValue::Color(color) = base_color {
                material.albedo_color = *color;
            }
        }
        
        if let Some(metallic) = output_node.inputs.get("Metallic") {
            if let MaterialValue::Scalar(value) = metallic {
                material.metallic = *value;
            }
        }
        
        if let Some(roughness) = output_node.inputs.get("Roughness") {
            if let MaterialValue::Scalar(value) = roughness {
                material.roughness = *value;
            }
        }
        
        if let Some(emission) = output_node.inputs.get("Emission") {
            if let MaterialValue::Color(color) = emission {
                material.emission = [color[0], color[1], color[2]];
                material.emission_strength = color[3]; // Use alpha as strength
            }
        }
    }
}

pub struct MaterialPlugin;

impl Plugin for MaterialPlugin {
    fn build(&self, app: &mut App) {
        app
            .init_resource::<MaterialLibrary>()
            .init_resource::<MaterialEditorState>()
            .add_system(material_editor_ui);
    }
}
